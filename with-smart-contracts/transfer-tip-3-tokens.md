# Transfer TIP-3 tokens

As we learned earlier from [here](../with-using-account/transfer-tip-3-tokens.md), TIP-3 has two implementations of the transfer.

```solidity
/*
    Transfer tokens and optionally deploy TokenWallet for recipient
    @dev Can be called only by TokenWallet owner
    @dev If deployWalletValue !=0 deploy token wallet for recipient using that gas value
    @param amount How much tokens to transfer
    @param recipient Tokens recipient address
    @param deployWalletValue How much EVERs to attach to token wallet deploy
*/

function transfer(
        uint128 _amount,
        address _recipient,
        uint128 _deployWalletValue,
        address _tokenRoot
    ) public onlyOwner {
        require(wallets.exists(_tokenRoot), Errors.WALLET_NOT_EXISTS);
        Wallet wallet = wallets[_tokenRoot];
        require(wallet.balance >= _amount, Errors.NOT_ENOUGH_BALANCE);
        tvm.accept();

        wallet.balance -= _amount;
        wallets[_tokenRoot] = wallet;

        TvmCell _empty;
        ITokenWallet(wallet.tokenWallet).transfer{
            value: _deployWalletValue + msgFee,
            flag: TokenMsgFlag.IGNORE_ERRORS,
            bounce: true
            } ({
                amount: _amount,
                recipient: _recipient,
                deployWalletValue: _deployWalletValue,
                remainingGasTo: address(this),
                notify: true,
                payload: _empty
        });

    }
```

#### Finally, it's time to talk about important bounce and notify

{% hint style="info" %}
To understand how notifications work, let's build a message chain in the transfer
{% endhint %}

<img src="../.gitbook/assets/file.drawing (1).svg" alt="Successful Transfer" class="gitbook-drawing">

{% hint style="info" %}
Bounce  - if it's set and transaction (generated by the internal outbound message) falls (only at the computing phase, not at the action phase!) then funds will be returned. Otherwise, (flag isn't set or transaction terminated successfully) the address accepts the funds even if the account doesn't exist or is frozen. Defaults to `true`.
{% endhint %}

Let's add bounce handling to our code

```solidity
onBounce(TvmSlice body) external {
    tvm.rawReserve(_reserve(), 2);

    uint32 functionId = body.decode(uint32);

    if (functionId == tvm.functionId(ITokenWallet.transfer)) {
        uint128 amount = body.decode(uint128);
        require(tokenRoots.exists(msg.sender), Errors.NOT_TOKEN_WALLET);

        address tokenRoot = tokenRoots[msg.sender];
        Wallet wallet = wallets[tokenRoot];
        wallet.balance += amount;
        wallets[tokenRoot] = wallet;
    }
}
```

{% hint style="info" %}
`onBounce` function is executed when contract receives a bounced inbound internal message. The message is generated by the network if the contract sends an internal message with `bounce: true` and either

* called contract doesn't exist;
* called contract fails at the storage/credit/computing phase (not at the action phase!)

The message is generated only if the remaining message value is enough for sending one back.

`body` is empty or contains at most **256** data bits of the original message (without references). The function id takes **32** bits and parameters can take at most **224** bits. It depends on the network config. If `onBounce` function is not defined then the contract does nothing on receiving a bounced inbound internal message.

If the `onBounce` function throws an exception then another bounced messages are not generated.
{% endhint %}

<img src="../.gitbook/assets/file.drawing.svg" alt="Failed Transfer on Sender side" class="gitbook-drawing">



{% hint style="info" %}
As we have already figured out, the bounce works only if an error occurred on the called contract.

Using the transfer method as an example, what happens if the recipient runs out of Gas or some other error?

If you look at the source code of the wallet token, then when you call the AcceptTransfer function on the recipient of the tokens, a bounce with the value of true is passed. Then the Token Wallet of the recipient will bounce to the Token Wallet of the sender.

And in the original TIP-3 repository, we can observe that the wallet token calls the wallet owner method `onBounceTokensTransfer`\

{% endhint %}

```solidity
onBounce(TvmSlice body) external {
    tvm.rawReserve(_reserve(), 2);

    uint32 functionId = body.decode(uint32);

    if (functionId == tvm.functionId(ITokenWallet.acceptTransfer)) {
        uint128 amount = body.decode(uint128);
        balance_ += amount;
        IBounceTokensTransferCallback(owner_).onBounceTokensTransfer{
            value: 0,
            flag: TokenMsgFlag.ALL_NOT_RESERVED + TokenMsgFlag.IGNORE_ERRORS,
            bounce: false
        }(
            root_,
            amount,
            msg.sender
      );
```



<img src="../.gitbook/assets/file.drawing (3).svg" alt="Failed Transfer or recipient side" class="gitbook-drawing">

Let's develop a method

```solidity
function onBounceTokensTransfer(
        address tokenRoot,
        uint128 amount,
        address revertedFrom
    ) public onlyTokenWallet(tokenRoot) {
        tvm.accept();
        Wallet wallet = wallets[tokenRoot];
        wallet.balance += amount;
        wallets[tokenRoot] = wallet;
        revertedFrom;
    }
```



Let's add another method so that we know about the replenishment of our wallets, and see what happens by connecting everything together

```solidity
pragma ton-solidity >= 0.61.2;
pragma AbiHeader expire;
pragma AbiHeader pubkey;

import '@broxus/contracts/contracts/utils/CheckPubKey.sol';
import '@broxus/contracts/contracts/utils/RandomNonce.sol';
import '@broxus/contracts/contracts/access/ExternalOwner.sol';
import "@broxus/tip3/contracts/interfaces/ITokenRoot.sol";
import "@broxus/tip3/contracts/interfaces/ITokenWallet.sol";
import "@broxus/tip3/contracts/libraries/TokenMsgFlag.sol";

import "./libraries/Errors.sol";

contract MultiWalletTIP3 is CheckPubKey, ExternalOwner, RandomNonce {
    uint128 constant msgFee = 0.5 ever;
    uint128 constant computeFee = 0.1 ever;

    struct Wallet {
        address tokenWallet;
        uint256 balance;
    }
    // tokenRoot => Wallet
    mapping (address => Wallet) public wallets;

    //mapping (address => address[]) public allowances;

    // tokenWallet => TokenRoot
    mapping (address => address) public tokenRoots;

    address awaitedRoot;

    modifier onlyTokenRoot(address _tokenRoot) {
      require(wallets.exists(_tokenRoot), Errors.NOT_TOKEN_ROOT);
      _;
    }

    modifier onlyTokenWallet(address _tokenRoot) {
      require(msg.sender == wallets[_tokenRoot].tokenWallet, Errors.NOT_TOKEN_WALLET);
      _;
    }
    constructor(
    ) public checkPubKey {
        tvm.accept();
        setOwnership(msg.pubkey());
    }

    function deployWallet(
        uint128 _deployWalletBalance,
        address _tokenRoot
    ) public onlyOwner {
        require(!wallets.exists(_tokenRoot), Errors.WALLET_EXISTS);
        tvm.accept();

        awaitedRoot = _tokenRoot;
        ITokenRoot(_tokenRoot).deployWallet{
            value: _deployWalletBalance + msgFee,
            flag: 2,
            callback: MultiWalletTIP3.receiveTokenWalletAddress
        }(
            address(this), // Now the owner of the wallet token will be TIP3Account
            _deployWalletBalance
        );
    }

    function receiveTokenWalletAddress(address wallet) external {
        //require(msg.sender == awaitedRoot, 200, "Sender is not awaited Token Root");
        wallets[msg.sender] = Wallet(wallet, 0);
        tokenRoots[wallet] = awaitedRoot;
        awaitedRoot = address(0);
    }
    /*
        @notice Transfer tokens and optionally deploy TokenWallet for recipient
        @dev Can be called only by TokenWallet owner
        @dev If deployWalletValue !=0 deploy token wallet for recipient using that gas value
        @param amount How much tokens to transfer
        @param recipient Tokens recipient address
        @param deployWalletValue How much EVERs to attach to token wallet deploy
    */
    function transfer(
        uint128 _amount,
        address _recipient,
        uint128 _deployWalletValue,
        address _tokenRoot
    ) public onlyOwner {
        require(wallets.exists(_tokenRoot), 222);
        Wallet wallet = wallets[_tokenRoot];
        require(wallet.balance >= _amount, 202);
        tvm.accept();

        wallet.balance -= _amount;
        wallets[_tokenRoot] = wallet;

        TvmCell _empty;
        ITokenWallet(wallet.tokenWallet).transfer{
            value: _deployWalletValue + msgFee,
            flag: TokenMsgFlag.IGNORE_ERRORS,
            bounce: true
            } ({
                amount: _amount,
                recipient: _recipient,
                deployWalletValue: _deployWalletValue,
                remainingGasTo: address(this),
                notify: true,
                payload: _empty
        });

    }

    function onAcceptTokensTransfer(
        address tokenRoot,
        uint128 amount,
        address sender,
        address senderWallet,
        address remainingGasTo,
        TvmCell payload
    ) external onlyTokenWallet(tokenRoot) {
        Wallet wallet = wallets[tokenRoot];
        wallet.balance += amount;
        wallets[tokenRoot] = wallet;

        tokenRoot;
        sender;
        senderWallet;
        remainingGasTo;
        payload;
    }


    function onBounceTokensTransfer(
        address tokenRoot,
        uint128 amount,
        address revertedFrom
    ) public onlyTokenWallet(tokenRoot) {
        tvm.accept();
        Wallet wallet = wallets[tokenRoot];
        wallet.balance += amount;
        wallets[tokenRoot] = wallet;
        revertedFrom;
    }

    onBounce(TvmSlice body) external {
        tvm.rawReserve(_reserve(), 2);

        uint32 functionId = body.decode(uint32);

        if (functionId == tvm.functionId(ITokenWallet.transfer)) {
            uint128 amount = body.decode(uint128);
            require(tokenRoots.exists(msg.sender), Errors.NOT_TOKEN_WALLET);

            address tokenRoot = tokenRoots[msg.sender];
            Wallet wallet = wallets[tokenRoot];
            wallet.balance += amount;
            wallets[tokenRoot] = wallet;
        }
    }
    function _reserve() public pure returns(uint128 reserve){
        return msgFee + computeFee;
    }

}

```

{% hint style="info" %}
Since `onBounces` has an implicit implementation, we can be sure that the sender will always be a trusted contract.

In contrast, from cases where our callback methods can call everything, and we need to check msg.sender
{% endhint %}



And in the end, let's look at the implementation of the transfer to TokenWallet.

In fact, the implementation differs only in that there is no deployWalletValue and we indicate the recipient Token Wallet, and not its owner

```solidity
    /*
        @notice Transfer tokens using another TokenWallet address, that wallet must be deployed previously
        @dev Can be called only by token wallet owner
        @param amount How much tokens to transfer
        @param recipientWallet Recipient TokenWallet address
    */
    function transferToWallet(
        address _tokenRoot,
        uint128 _amount,
        address _recipientTokenWallet
    ) public onlyOwner {
        require(wallets.exists(_tokenRoot), Errors.WALLET_NOT_EXISTS);
        Wallet wallet = wallets[_tokenRoot];
        require(wallet.balance >= _amount, Errors.NOT_ENOUGH_BALANCE);
        tvm.accept();

        wallet.balance -= _amount;
        wallets[_tokenRoot] = wallet;

        TvmCell _empty;
        ITokenWallet(wallet.tokenWallet).transferToWallet{
            value: msgFee,
            flag: TokenMsgFlag.IGNORE_ERRORS,
            bounce: true
            } ({
                amount: _amount,
                recipientTokenWallet: _recipientTokenWallet,
                remainingGasTo: address(this),
                notify: true,
                payload: _empty
        });

    }

```





{% hint style="info" %}
You probably noticed that we have a new TМM method in the code -&#x20;

`tvm.rawReserve(uint value, uint8 flag);`



Creates an output action that reserves **reserve** nanotons. It is roughly equivalent to create an outbound message carrying **reserve** nanotons to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. It's a wrapper for opcodes "RAWRESERVE" and "RAWRESERVEX". See [TVM](https://test.ton.org/tvm.pdf).\

{% endhint %}

{% hint style="info" %}
`By tvm.accept` and `tvm.rawReserve`is determined by an external function or internal.\
\
Note: If the function has `tvm.rawReserve`then only a smart contract can call it.

But if the function has an acceptance, then it can be called by an external message and an internal one.\
\
If you need to make the function available only for external messages, add a&#x20;

require(msg.sender == address(0))
{% endhint %}

